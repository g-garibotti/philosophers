===============================
    PHILOSOPHERS PSEUDOCODE
===============================

---------------------------
    DATA STRUCTURES
---------------------------

struct Philosopher:
    id              : integer
    left_fork       : integer
    right_fork      : integer
    eat_count       : integer
    last_meal_time  : timestamp
    thread          : thread_id

struct SimulationData:
    philosophers    : array of Philosopher
    forks           : array of mutex
    death_mutex     : mutex
    print_mutex     : mutex
    sim_stop        : boolean
    time_to_die     : integer
    time_to_eat     : integer
    time_to_sleep   : integer
    num_of_philos   : integer
    num_times_to_eat: integer (optional)

---------------------------
    MAIN FUNCTION
---------------------------

function main(arguments):
    if not validate_arguments(arguments):
        print_error("Invalid arguments")
        return ERROR

    sim_data = initialize_simulation(arguments)
    if not sim_data:
        print_error("Failed to initialize simulation")
        return ERROR

    start_simulation(sim_data)
    cleanup_simulation(sim_data)
    return SUCCESS

---------------------------
    INITIALIZATION
---------------------------

function initialize_simulation(arguments):
    sim_data = create_simulation_data_structure()
    parse_arguments(arguments, sim_data)
    initialize_mutexes(sim_data)
    initialize_philosophers(sim_data)
    return sim_data

---------------------------
    PHILOSOPHER ROUTINE
---------------------------

function philosopher_routine(philosopher_id, sim_data):
    while not sim_data.sim_stop:
        think(philosopher_id, sim_data)
        if not eat(philosopher_id, sim_data):
            break
        sleep(philosopher_id, sim_data)
    return NULL

function eat(philosopher_id, sim_data):
    philosopher = sim_data.philosophers[philosopher_id]
    
    # Acquire forks
    lock(sim_data.forks[philosopher.left_fork])
    print_status(philosopher_id, "has taken a fork", sim_data)
    lock(sim_data.forks[philosopher.right_fork])
    print_status(philosopher_id, "has taken a fork", sim_data)

    # Check if simulation should stop
    lock(sim_data.death_mutex)
    if sim_data.sim_stop:
        unlock(sim_data.death_mutex)
        unlock(sim_data.forks[philosopher.right_fork])
        unlock(sim_data.forks[philosopher.left_fork])
        return FALSE

    # Eat
    print_status(philosopher_id, "is eating", sim_data)
    philosopher.last_meal_time = get_current_time()
    philosopher.eat_count++
    unlock(sim_data.death_mutex)

    precise_sleep(sim_data.time_to_eat)

    # Release forks
    unlock(sim_data.forks[philosopher.right_fork])
    unlock(sim_data.forks[philosopher.left_fork])

    return TRUE

function think(philosopher_id, sim_data):
    print_status(philosopher_id, "is thinking", sim_data)

function sleep(philosopher_id, sim_data):
    print_status(philosopher_id, "is sleeping", sim_data)
    precise_sleep(sim_data.time_to_sleep)

---------------------------
    DEATH CHECKER
---------------------------

function death_checker(sim_data):
    while not sim_data.sim_stop:
        for each philosopher in sim_data.philosophers:
            lock(sim_data.death_mutex)
            time_since_last_meal = get_current_time() - philosopher.last_meal_time
            if time_since_last_meal > sim_data.time_to_die:
                print_status(philosopher.id, "died", sim_data)
                sim_data.sim_stop = TRUE
                unlock(sim_data.death_mutex)
                return NULL
            unlock(sim_data.death_mutex)
        
        precise_sleep(1)  # Prevent busy-waiting

    return NULL

---------------------------
    UTILITY FUNCTIONS
---------------------------

function print_status(philosopher_id, status, sim_data):
    lock(sim_data.print_mutex)
    print(get_current_time(), philosopher_id, status)
    unlock(sim_data.print_mutex)

function precise_sleep(milliseconds):
    # Implementation of precise sleep function

function get_current_time():
    # Implementation to get current time in milliseconds

---------------------------
    SIMULATION CONTROL
---------------------------

function cleanup_simulation(sim_data):
    join_all_threads(sim_data)
    destroy_all_mutexes(sim_data)
    free_allocated_memory(sim_data)

function start_simulation(sim_data):
    create_philosopher_threads(sim_data)
    create_death_checker_thread(sim_data)
    wait_for_simulation_to_end(sim_data)

===============================
         END OF FILE
===============================
